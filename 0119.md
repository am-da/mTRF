


### 最良の相関係数を求める。(交差検証なし)
<details><summary>コード</summary>
  
```python
import numpy as np
import matplotlib.pyplot as plt

# 試行するtminとtmaxの範囲を指定
tmin_range = np.linspace(-0.3, -0.01, 100)
tmax_range = np.linspace(0.01, 0.3, 100)

best_corrcoef = -1  # 最良の相関係数を初期化
best_tmin = None
best_tmax = None

# モデル用にデータを準備。faceデータを転置し、モデルの出力データ(EEG)Yを取得。
face = face.T
Y, _ = raw[:] 
Y = Y.T
coefs = np.zeros((n_splits, n_channels, n_delays))
scores = np.zeros((n_splits, n_channels))

# 各tminとtmaxの組み合わせに対して相関係数を計算
for tmax in tmax_range:
    for tmin in tmin_range:
        rf = ReceptiveField(tmin, tmax, sfreq, feature_names=["envelope"], estimator=1.0, scoring="corrcoef")
        n_delays = int((tmax - tmin) * sfreq) + 2
        X_train = face[train][:, np.newaxis]
        rf.fit(X_train, Y[train])
        X_test = face[test][:, np.newaxis]
        scores[ii] = rf.score(X_test, Y[test])
        coefs[ii] = (rf.coef_[:, 0, :])
        mean_scores = scores.mean(axis=0)
        if np.mean(mean_scores) > best_corrcoef:
          best_corrcoef = np.mean(mean_scores)
          best_tmin = tmin
          best_tmax = tmax

# 結果の出力
print(f"Best tmin: {best_tmin}, Best tmax: {best_tmax}, Best Correlation Coefficient: {best_corrcoef}")
```

```python
Best tmin: -0.3, Best tmax: 0.01, Best Correlation Coefficient: 0.0017133763718476859
```
</details>



### 最良の相関係数を求める。(交差検証あり)
<details><summary>コード</summary>
  
```python
import numpy as np
import matplotlib.pyplot as plt

# 試行するtminとtmaxの範囲を指定
tmin_range = np.linspace(-0.3, -0.01, 100)
tmax_range = np.linspace(0.01, 0.3, 100)

best_corrcoef = -1  # 最良の相関係数を初期化
best_tmin = None
best_tmax = None

# 交差検証のための分割数を設定し、KFoldクラスを初期化
n_splits = 3
cv = KFold(n_splits)

# モデル用にデータを準備。faceデータを転置し、モデルの出力データ(EEG)Yを取得。
face = face.T
Y, _ = raw[:] 
Y = Y.T

# 各tminとtmaxの組み合わせに対して相関係数を計算
for tmax in tmax_range:
    for tmin in tmin_range:
        rf = ReceptiveField(tmin, tmax, sfreq, feature_names=["envelope"], estimator=1.0, scoring="corrcoef")
        n_delays = int((tmax - tmin) * sfreq) + 2
        coefs = np.zeros((n_splits, n_channels, n_delays))
        scores = np.zeros((n_splits, n_channels))
        for ii, (train, test) in enumerate(cv.split(face)):
          X_train = face[train][:, np.newaxis]
          rf.fit(X_train, Y[train])
          X_test = face[test][:, np.newaxis]
          scores[ii] = rf.score(X_test, Y[test])
          coefs[ii] = (rf.coef_[:, 0, :])
        mean_scores = scores.mean(axis=0)
        if np.mean(mean_scores) > best_corrcoef:
          best_corrcoef = np.mean(mean_scores)
          best_tmin = tmin
          best_tmax = tmax

# 結果の出力
print(f"Best tmin: {best_tmin}, Best tmax: {best_tmax}, Best Correlation Coefficient: {best_corrcoef}")

```

```python
Best tmin: -0.3, Best tmax: 0.01, Best Correlation Coefficient: -0.01598082083947267

```

</details>


### エラー
<details><summary>コード</summary>
  
```python

<stdin>:10: FutureWarning: Support for multi-dimensional indexing (e.g. `obj[:, None]`) is deprecated and will be removed in a future version.  Convert to a numpy array before indexing instead.
Traceback (most recent call last):
  File "<stdin>", line 12, in <module>
ValueError: could not broadcast input array from shape (32,20) into shape (32,21)

```
</details>



### データの正規化
<details><summary>コード</summary>
  
```python

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat
from os.path import join
import mne

from mne.decoding import ReceptiveField
from sklearn.model_selection import KFold
from sklearn.preprocessing import scale
import pandas as pd

# 前処理あり
eeg_path = "/Users/ami/Desktop/UCSD/prepro_16.fif"

# 顔表情特徴量のCSVファイルパス
face_path = "/Users/ami/Desktop/UCSD/result_mix/16/out_extract_16/extracted_data16_27.csv"

# EEGデータの読み込み
raw = mne.io.read_raw_fif(eeg_path, preload=True)
sfreq = raw.info['sfreq'] # サンプリング周波数を取得
n_channels = len(raw.ch_names) # チャンネル数を取得

# 顔表情特徴量の読み込み
face_data = pd.read_csv(face_path)
face = face_data.iloc[:, 4]  # 特定の特徴量(列)のみを抜粋
print(face)

# ダウンサンプリング(いらない？)(計算を高速化するため)
decim = 2 #(任意の変数)
sfreq /= decim
# 元のサンプリング周波数を2で割ることによりダウンサンプリングを行う
face = mne.filter.resample(face, down=decim, method="polyphase")
raw = mne.filter.resample(raw, down=decim, method="polyphase")

# 60秒間のデータを抽出する時間帯を設定(動画の開始時間と終了時間)
start_time = 1538.71484375
end_time = start_time + 60
raw.crop(tmin=start_time, tmax=end_time) # 指定した時間帯のデータを抽出

# EEGデータのモンタージュ作成
montage = mne.channels.make_standard_montage("biosemi32")

# チャンネル数を取得
n_channels = len(montage.ch_names) # モンタージュのチャンネル数を取得します

# MNEのinfoオブジェクトを作成し、その中に脳波データに関する基本的な情報と電極の配置情報を組み込む
info = mne.create_info(montage.ch_names, sfreq, "eeg")

# 生の脳波データをMNEのRawArrayオブジェクトに変換(info + EEGデータを合わせる)
data = raw.get_data() # EEGデータを取得
raw = mne.io.RawArray(data[:n_channels, :], info) # データとinfoを合わせて新しいRawArrayを作成

# プロット
fig, ax = plt.subplots()
lns = ax.plot(scale(raw[:, :60][0].T), color="b", alpha=0.2) # EEGデータをプロット
ln1 = ax.plot(scale(face[:60]), color="r", lw=2)  #顔表情特徴量をプロット
ax.legend([lns[0], ln1[0]], ["EEG", "face"], frameon=False)
ax.set(title="Sample activity", xlabel="Time (s)")
mne.viz.tight_layout()
plt.show()

# scale()は、データの平均が0になり、標準偏差が1になるように変換される(平均0・分散1に正規化（標準化）)
# この変換により、データの単位や分布の差異に関係なく
# 異なるデータソースのデータを比較しやすくなり、グラフにプロットすることができる

```

</details>



### モデルの作成
<details><summary>コード</summary>

```python

#mTRFツールボックスと同様のことが、mne.decoding.ReceptiveFieldクラスでできる
#mne.decoding.ReceptiveFieldは、時間遅延を考慮した入力特徴量を使用して、
#エンコーディングモデル（刺激から脳へのモデル）またはデコーディングモデル（脳から刺激へのモデル）を適合させるためのクラス
#時間遅延を考慮した表情特徴量とEEGの間の線形関係を見つけるためのエンコードモデルを構築。
#これにより、新しい刺激に対する反応を予測することができる。

# ReceptiveFieldで使用するdelayを定義
tmin, tmax = -0.3, 0.01

# ReceptiveFieldモデルを初期化
#指定した時間範囲（tminからtmaxまで）、サンプリング周波数（sfreq）を持ち、特徴量名とスコアリング方法を設定
#feature_names: モデルの入力特徴量の名前（オプション）。指定しない場合、fitを実行した後に入力データの形状から自動生成
#estimator: モデルの適合に使用する推定器（scikit-learnスタイルのモデル）またはRidge回帰モデルのアルファパラメータ。Noneの場合、Ridge回帰モデル（アルファ=0）が使用される
rf = ReceptiveField(
    tmin, tmax, sfreq, feature_names=["envelope"], estimator=1.0, scoring="corrcoef"
)

# 指定された遅延の範囲内におけるサンプリングポイントの数を算出
# 開始/終了インデックスも含むため、追加で2つの遅延がある
n_delays = int((tmax - tmin) * sfreq) + 2

# 交差検証のための分割数を設定し、KFoldクラスを初期化
n_splits = 3
cv = KFold(n_splits)

# モデルようにデータを準備。faceデータを転置し、モデルの出力データ(EEG)Yを取得。
face = face.T
Y, _ = raw[:] 
Y = Y.T

# 特徴量とEEGの間の線形関係を評価するために、モデルを学習させる
# スプリットごとにモデルを適合させ、予測/テストを繰り返す
coefs = np.zeros((n_splits, n_channels, n_delays))
scores = np.zeros((n_splits, n_channels))

for ii, (train, test) in enumerate(cv.split(face)):
    print("split %s / %s" % (ii + 1, n_splits))
    
    X_train = face[train][:, np.newaxis]  # n_featuresのために新しい軸を追加
    
    # モデルを適合
    rf.fit(X_train, Y[train])
    
    # 同じ形状のテストデータを準備
    X_test = face[test][:, np.newaxis]
    
    # スコアと係数を計算
    scores[ii] = rf.score(X_test, Y[test])
    coefs[ii] = rf.coef_[:, 0, :]

print(scores)
mean_scores = scores.mean(axis=0)

print(mean_scores)

# 遅延の配列を計算
delays = np.linspace(tmin, tmax, n_delays)

times = np.arange(n_delays) * (1.0 / sfreq)

# 交差検証スプリットごとのスコアと係数を平均化
mean_coefs = coefs.mean(axis=0)
mean_scores = scores.mean(axis=0)

# 平均予測スコアをプロット
fig, ax = plt.subplots()
ix_chs = np.arange(n_channels)
ax.plot(ix_chs, mean_scores)
ax.axhline(0, ls="--", color="r")
ax.set(title="Mean prediction score", xlabel="Channel", ylabel="Score ($r$)")
mne.viz.tight_layout()
plt.show()

#縦の値は相関係数
#この相関係数は、脳活動と外部刺激がどれだけ同期しているかを示す指標であり、
#高い相関係数は、脳活動が外部刺激に対して敏感であることを示す

```

</details>
