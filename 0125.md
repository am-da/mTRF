

### 最良の相関係数を求める
<details><summary>コード</summary>

tmin ~ tmaxの範囲で最適なタイムラグを選択?

```python
import numpy as np
from mne.decoding import ReceptiveField
from sklearn.model_selection import KFold

# ターゲットの相関係数の最大値とその組み合わせを保存する変数を初期化
max_corr = -np.inf
best_tmin = None
best_tmax = None

# 交差検証のための分割数を設定し、KFoldクラスを初期化
n_splits = 3
cv = KFold(n_splits)

# モデルようにデータを準備。faceデータを転置し、モデルの出力データ(EEG)Yを取得。
face = face.T
Y, _ = raw[:] 
Y = Y.T

# 試す遅延の範囲
tmin_range = np.linspace(-0.5, -0.00, 20)
tmax_range = np.linspace(0.00, 0.5, 20)

# 探索範囲内での相関係数を計算
for tmin_candidate in tmin_range:
    for tmax_candidate in tmax_range:
        # ReceptiveFieldで使用するdelayを設定
        tmin, tmax = tmin_candidate, tmax_candidate
        # ReceptiveFieldモデルを初期化
        rf = ReceptiveField(tmin, tmax, sfreq, feature_names=["envelope"], estimator=1.0, scoring="corrcoef")
        # 交差検証スコアを計算
        scores = np.zeros((n_splits, n_channels))
        for ii, (train, test) in enumerate(cv.split(face)):
            X_train = face[train][:, np.newaxis]
            rf.fit(X_train, Y[train])
            X_test = face[test][:, np.newaxis]
            scores[ii] = rf.score(X_test, Y[test])
        # 平均スコアを計算
        mean_scores = scores.mean(axis=0)
        # 最大相関係数とその組み合わせを更新
        if mean_scores.max() > max_corr:
            max_corr = mean_scores.max()
            best_tmin = tmin
            best_tmax = tmax

# 結果を表示
print(f"最大相関係数: {max_corr}")
print(f"最適なtmin: {best_tmin}")
print(f"最適なtmax: {best_tmax}")

```

>>> print(f"最大相関係数: {max_corr}")
最大相関係数: 0.08369112362438363
>>> print(f"最適なtmin: {best_tmin}")
最適なtmin: -0.0
>>> print(f"最適なtmax: {best_tmax}")
最適なtmax: 0.23684210526315788

</details>


### 最良の相関係数を使って計算
tmin = 0
tmax = 0.23
<details><summary>コード</summary>

```python
#mTRFツールボックスと同様のことが、mne.decoding.ReceptiveFieldクラスでできる
#mne.decoding.ReceptiveFieldは、時間遅延を考慮した入力特徴量を使用して、
#エンコーディングモデル（刺激から脳へのモデル）を適合させるためのクラス
#時間遅延を考慮した表情特徴量とEEGの間の線形関係を見つけるためのエンコードモデルを構築。
#これにより、新しい刺激に対する反応を予測することができる。

# ReceptiveFieldで使用するdelayを定義
tmin, tmax = -0.2, 0.4

# ReceptiveFieldモデルを初期化
#指定した時間範囲（tminからtmaxまで）、サンプリング周波数（sfreq）を持ち、特徴量名とスコアリング方法を設定
#feature_names: モデルの入力特徴量の名前（オプション）。指定しない場合、fitを実行した後に入力データの形状から自動生成
#estimator: モデルの適合に使用する推定器（scikit-learnスタイルのモデル）またはRidge回帰モデルのアルファパラメータ。Noneの場合、Ridge回帰モデル（アルファ=0）が使用される
rf = ReceptiveField(
    tmin, tmax, sfreq, feature_names=["envelope"], estimator=1.0, scoring="corrcoef"
)

# 指定された遅延の範囲内におけるサンプリングポイントの数を算出
# 開始/終了インデックスも含むため、追加で2つの遅延がある
n_delays = int((tmax - tmin) * sfreq) + 2

# 交差検証のための分割数を設定し、KFoldクラスを初期化
n_splits = 3
cv = KFold(n_splits)

# モデルようにデータを準備。faceデータを転置し、モデルの出力データ(EEG)Yを取得。
face = face.T
Y, _ = raw[:] 
Y = Y.T

# 特徴量とEEGの間の線形関係を評価するために、モデルを学習させる
# スプリットごとにモデルを適合させ、予測/テストを繰り返す
coefs = np.zeros((n_splits, n_channels, n_delays))
scores = np.zeros((n_splits, n_channels))

for ii, (train, test) in enumerate(cv.split(face)):
    print("split %s / %s" % (ii + 1, n_splits))
    
    X_train = face[train][:, np.newaxis]  # n_featuresのために新しい軸を追加
    
    # モデルを適合
    rf.fit(X_train, Y[train])
    
    # 同じ形状のテストデータを準備
    X_test = face[test][:, np.newaxis]
    
    # スコアと係数を計算
    scores[ii] = rf.score(X_test, Y[test])
    coefs[ii] = rf.coef_[:, 0, :]

# 遅延の配列を計算
delays = np.linspace(tmin, tmax, n_delays)

times = np.arange(n_delays) * (1.0 / sfreq)
mean_times = times.mean()
print(mean_times)

# 交差検証スプリットごとのスコアと係数を平均化
mean_coefs = coefs.mean(axis=0)
mean_scores = scores.mean(axis=0)
print(mean_scores)

# 平均予測スコアをプロット
fig, ax = plt.subplots()
ix_chs = np.arange(n_channels)
ax.plot(ix_chs, mean_scores)
ax.axhline(0, ls="--", color="r")
ax.set(title="Mean prediction score", xlabel="Channel", ylabel="Score ($r$)")
mne.viz.tight_layout()
plt.show()

#縦の値は相関係数
#この相関係数は、脳活動と外部刺激がどれだけ同期しているかを示す指標であり、
#高い相関係数は、脳活動が外部刺激に対して敏感であることを示す

<img width="631" alt="スクリーンショット 2024-01-26 6 26 05" src="https://github.com/am-da/mTRF/assets/112613519/0891ab03-d69f-416b-b3c7-db5550f0a23b">
```
</details>


横軸タイムラグ、縦軸相関の平均のグラフ
<details><summary>コード</summary>


```python


```
</details>
