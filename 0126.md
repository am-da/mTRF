

### 相関係数が最大になる組み合わせを求める
tmin ~ tmaxの範囲の中で最適なタイムラグを選択してくれる?
<details><summary>コード</summary>


```python
import numpy as np
from mne.decoding import ReceptiveField
from sklearn.model_selection import KFold

# ターゲットの相関係数の最大値とその組み合わせを保存する変数を初期化
max_corr = -np.inf
best_tmin = None
best_tmax = None

# 交差検証のための分割数を設定し、KFoldクラスを初期化
n_splits = 3
cv = KFold(n_splits)

# モデルようにデータを準備。faceデータを転置し、モデルの出力データ(EEG)Yを取得。
face = face.T
Y, _ = raw[:] 
Y = Y.T

# 試す遅延の範囲
tmin_range = np.linspace(-0.5, -0.00, 20)
tmax_range = np.linspace(0.00, 0.5, 20)

# 探索範囲内での相関係数を計算
for tmin_candidate in tmin_range:
    for tmax_candidate in tmax_range:
        # ReceptiveFieldで使用するdelayを設定
        tmin, tmax = tmin_candidate, tmax_candidate
        # ReceptiveFieldモデルを初期化
        rf = ReceptiveField(tmin, tmax, sfreq, feature_names=["envelope"], estimator=1.0, scoring="corrcoef")
        # 交差検証スコアを計算
        scores = np.zeros((n_splits, n_channels))
        for ii, (train, test) in enumerate(cv.split(face)):
            X_train = face[train][:, np.newaxis]
            rf.fit(X_train, Y[train])
            X_test = face[test][:, np.newaxis]
            scores[ii] = rf.score(X_test, Y[test])
        # 平均スコアを計算
        mean_scores = scores.mean(axis=0)
        # 最大相関係数とその組み合わせを更新
        if mean_scores.max() > max_corr:
            max_corr = mean_scores.max()
            best_tmin = tmin
            best_tmax = tmax

# 結果を表示
print(f"最大相関係数: {max_corr}")
print(f"最適なtmin: {best_tmin}")　　
print(f"最適なtmax: {best_tmax}")

```

print(f"最大相関係数: {max_corr}")　　　　

最大相関係数: 0.08369112362438363　　　　

print(f"最適なtmin: {best_tmin}")　　　　

最適なtmin: -0.0　　　

print(f"最適なtmax: {best_tmax}")　　

最適なtmax: 0.23684210526315788　　

</details>


### 相関係数が最大になるtmin,tmaxを使って計算
tmin = 0  
tmax = 0.23  
(tminが０なのは良さそう)  

<details><summary>コード</summary>

```python

#mTRFツールボックスと同様のことが、mne.decoding.ReceptiveFieldクラスでできる
#mne.decoding.ReceptiveFieldは、時間遅延を考慮した入力特徴量を使用して、
#エンコーディングモデル（刺激から脳へのモデル）を適合させるためのクラス
#時間遅延を考慮した表情特徴量とEEGの間の線形関係を見つけるためのエンコードモデルを構築。
#これにより、新しい刺激に対する反応を予測することができる。

# ReceptiveFieldで使用するdelayを定義
tmin, tmax = -0.0, 0.23

# ReceptiveFieldモデルを初期化
#指定した時間範囲（tminからtmaxまで）、サンプリング周波数（sfreq）を持ち、特徴量名とスコアリング方法を設定
#feature_names: モデルの入力特徴量の名前（オプション）。指定しない場合、fitを実行した後に入力データの形状から自動生成
#estimator: モデルの適合に使用する推定器（scikit-learnスタイルのモデル）またはRidge回帰モデルのアルファパラメータ。Noneの場合、Ridge回帰モデル（アルファ=0）が使用される
rf = ReceptiveField(
    tmin, tmax, sfreq, feature_names=["envelope"], estimator=1.0, scoring="corrcoef"
)

# 指定された遅延の範囲内におけるサンプリングポイントの数を算出
# 開始/終了インデックスも含むため、追加で2つの遅延がある
n_delays = int((tmax - tmin) * sfreq) + 2

# 交差検証のための分割数を設定し、KFoldクラスを初期化
n_splits = 3
cv = KFold(n_splits)

# モデルようにデータを準備。faceデータを転置し、モデルの出力データ(EEG)Yを取得。
face = face.T
Y, _ = raw[:] 
Y = Y.T

# 特徴量とEEGの間の線形関係を評価するために、モデルを学習させる
# スプリットごとにモデルを適合させ、予測/テストを繰り返す
coefs = np.zeros((n_splits, n_channels, n_delays))
scores = np.zeros((n_splits, n_channels))

for ii, (train, test) in enumerate(cv.split(face)):
    print("split %s / %s" % (ii + 1, n_splits))
    
    X_train = face[train][:, np.newaxis]  # n_featuresのために新しい軸を追加
    
    # モデルを適合
    rf.fit(X_train, Y[train])
    
    # 同じ形状のテストデータを準備
    X_test = face[test][:, np.newaxis]
    
    # スコア(相関)と係数を計算
    scores[ii] = rf.score(X_test, Y[test])
    coefs[ii] = rf.coef_[:, 0, :]
    # print(coefs[ii])
    # print(rf.delays_)

print(rf.delays_)
# 遅延の配列を計算
# rf.delays_はモデルが考慮する時間遅延の配列であり、それぞれの遅延が何秒であるかを理解するために、これをサンプリング周波数で割っている。
# これにより、遅延がサンプル単位ではなく、時間単位で表現されるようになる。
times = rf.delays_ / float(rf.sfreq)
print(times)

mean_times = times.mean()
# print(mean_times)

# 交差検証スプリットごとのスコアと係数(coef)を平均化
# 32この値が出てくる(チャンネル分)
mean_coefs = coefs.mean(axis=0)
mean_scores = scores.mean(axis=0)
print(mean_coefs.shape)
# print(scores)

# 平均予測スコアをプロット
fig, ax = plt.subplots()
ix_chs = np.arange(n_channels)
ax.plot(ix_chs, mean_scores)
ax.axhline(0, ls="--", color="r")
ax.set(title="Mean prediction score", xlabel="Channel", ylabel="Score ($r$)")
mne.viz.tight_layout()
plt.show()

#縦の値は相関係数
#この相関係数は、脳活動と外部刺激がどれだけ同期しているかを示す指標であり、
#高い相関係数は、脳活動が外部刺激に対して敏感であることを示す

```
</details>


 (tmin = 0, tmax = 0.23 ) ↓
 
 <img width="619" alt="スクリーンショット 2024-01-26 8 28 06" src="https://github.com/am-da/mTRF/assets/112613519/9b01b081-4d48-428c-816a-af015178f62a">

 (tmin = 0, tmax = 0.1 ) ↓
 
 <img width="630" alt="スクリーンショット 2024-01-26 6 48 54" src="https://github.com/am-da/mTRF/assets/112613519/eb7a8208-788a-4a32-81f2-f50232cffe01">


### マップ
<details><summary>コード</summary>


```python



# Print mean coefficients across all time delays / channels (see Fig 1)
time_plot = 0.180  # For highlighting a specific time.
fig, ax = plt.subplots(figsize=(4, 8))

# 'mean_coefs' 配列内の最大係数を取得します。
max_coef = mean_coefs.max()

# ヒートマップを作成し、係数を視覚化。'times' はX軸、'ix_chs' はY軸、'mean_coefs' は値。
# 'cmap' はカラーマップ、'vmin' および 'vmax' はカラーマップの値の範囲を指定。
ax.pcolormesh(
    times,
    ix_chs,
    mean_coefs,
    cmap="RdBu_r",
    vmin=-max_coef,
    vmax=max_coef,
    shading="gouraud",
)

ax.axvline(time_plot, ls="--", color="k", lw=2)
ax.set(
    xlabel="Delay (s)",
    ylabel="Channel",
    title="Mean Model\nCoefficients",
    xlim=times[[0, -1]],
    ylim=[len(ix_chs) - 1, 0],
    xticks=np.arange(tmin, tmax + 0.2, 0.2),
)

# X軸の目盛りラベルを45度回転
plt.setp(ax.get_xticklabels(), rotation=45)
mne.viz.tight_layout()

# 'times' 配列内で 'time_plot' に最も近い時間を探し、そのインデックスを 'ix_plot' に格納します。
ix_plot = np.argmin(np.abs(time_plot - times))
fig, ax = plt.subplots()

# "biosemi32" テンプレートを使用して Montage オブジェクト 'easycap_montage' を作成
easycap_montage = mne.channels.make_standard_montage("biosemi32")

# チャンネル名、サンプリング周波数、チャンネルタイプを指定して空の 'info' オブジェクトを作成
info = mne.create_info(ch_names=easycap_montage.ch_names, sfreq=1000.0, ch_types='eeg')

#'info' オブジェクトにモンタージュ情報を設定
info.set_montage(easycap_montage)

# マップを作成し、モデルの係数を視覚化。'mean_coefs' の特定の遅延に対する係数が表示される
# 'pos' はセンサーの位置情報、'axes' はグラフ描画のための軸を指定
# 'show=False' はプロットを直接表示しないように指定
mne.viz.plot_topomap(
    mean_coefs[:, ix_plot], pos=info, axes=ax, show=False, vlim=(-max_coef, max_coef)
)
ax.set(title="Topomap of model coefficients\nfor delay %s" % time_plot)
mne.viz.tight_layout()
plt.show()

```
</details>

<img width="624" alt="スクリーンショット 2024-01-26 8 29 03" src="https://github.com/am-da/mTRF/assets/112613519/535246e4-c76d-4249-90c3-6a97805835a1">  


<img width="388" alt="スクリーンショット 2024-01-26 8 29 12" src="https://github.com/am-da/mTRF/assets/112613519/c1620d0a-5d57-4d10-bfe3-4741e3582f49">

sample↓
<img width="557" alt="スクリーンショット 2024-01-26 8 51 42" src="https://github.com/am-da/mTRF/assets/112613519/ed8d38bb-8032-45b1-9eeb-45ac38f76a89">
